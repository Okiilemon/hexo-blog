<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Okiilemon</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Okiilemon">
<meta property="og:url" content="http://www.fehacker.com/index.html">
<meta property="og:site_name" content="Okiilemon">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Okiilemon">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Okiilemon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">Okiilemon</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.fehacker.com"></form>
	</div>
</header>
    <div id="main">
      
  
    <article id="post-DOM" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/11/21/DOM/" class="article-date">
  <time datetime="2015-11-20T16:47:55.000Z" itemprop="datePublished">2015-11-21</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
	</header>
	<div class="entry-content">
		
    	<h3 id="DOM深入解析">DOM深入解析</h3><p>DOM  Document Object Model 是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树。</p>
<h4 id="1998-10_W3C推荐标准_DOM1级规范">1998.10 W3C推荐标准 DOM1级规范</h4><h3 id="DOM">DOM</h3><h5 id="1-_Node类型">1. Node类型</h5><ul>
<li>每个节点都有一个<strong>nodeType</strong>属性，element类型对应的数值常量是 1 ，由于IE不支持Node接口，因此最好将nodeType属性与数值比较，来确保浏览器兼容性。</li>
<li><strong>nodeName</strong> 与 <strong>nodeValue</strong>, nodeName中保存着元素的标签名，只有部分node的nodeValue属性有值，其余都是null.</li>
<li>节点关系<ul>
<li>每一个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一个类数组对象，用于保存一组有序的节点，虽然这个对象也有length属性，但它并不是一个Array的实例。<ul>
<li><strong>Nodelist对象是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够实时反应在Nodelist对象中。</strong></li>
<li>可以通过方括号或者item方法来方位保存在NodeList在的节点</li>
<li>将NodeList对象转换为数组的方法：Array.prototype.slice.call( someNode.childNodes, 0 ) , 在IE8以前的版本不支持，需要手动枚举所有成员然后压入数组</li>
<li>每个节点都有如下关系节点属性：<ul>
<li>parentNode 指向父节点</li>
<li>nextSibling() previousSibling() 同胞节点之间</li>
<li>firstChild, lastChild 子节点</li>
</ul>
</li>
<li>节点方法 hasChildNodes(), 该节点如果包含一个以上子节点的情况下返回true,比childNodes.length来判断方便许多</li>
<li><strong>关于childNode.length IE9之前的版本不会为空白符创建节点</strong></li>
</ul>
</li>
</ul>
</li>
<li>操作节点<ul>
<li><strong>appendChild()</strong>接受一个参数，要插入的节点。用法：parent.appendChild(child) 用于向parent 的childNodes列表的末尾添加一个节点，return 新增节点</li>
<li>i<strong>nsertBrfore（）</strong> 接受两个参数，要插入的节点和作为参照的节点。用法：parent.insertBefore(newNode, dependNode), 如果第二个参数也就是参照节点是null，则执行与appendChild相同的操坐，return 新增节点。<ul>
<li>另外说说利用 insertBefore（） 实现 insertAfter() 的方法, 首先判断一下参照节点的下一个同胞节点是否存在，存在说明不是最后一个节点, 不存在就直接append<blockquote>
<p>function insertBefore(newNode, dependNode){<br>var parent = newNode.parentElement;<br>  if( dependNode.nextSibling === null ){       </p>
<pre><code><span class="tag">parent</span><span class="class">.appendChild</span>(<span class="tag">newNode</span>);      
</code></pre><p>  }<br>  else{         </p>
<pre><code>parent.<span class="function"><span class="title">insertBefore</span><span class="params">( newNode, dependNode.nextSibling )</span></span>      
</code></pre><p>  }<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>replaceChild()</strong> 接受两个参数，要插入的节点和要替换的节点，要替换的节点将由这个方法<strong>返回</strong>并从文档树中移除，同时被要插入的节点替换。被替换的节点仍然还在文档中，只是在文档中已经没有了自己位置。方法：parent.replaceChild(newNode，replacedChild) </li>
<li><strong>removeChild()</strong>，接受一个参数，即要被移除的节点，被移除的节点被返回。被移除的节点仍然在文档中，只是在文档中没有了自己位置。 方法： parent.removeChild(child)</li>
</ul>
</li>
</ul>
<pre><code>-<span class="ruby">--
</span>（以上四个方法都需要先取得父节点，并不是所有类型都有父节点）
-<span class="ruby"> 两个所有类型节点都有的方法
</span>    -<span class="ruby"> **cloneNode()**, 用于创建调用这个方法的节点的一个完全相同的副本, targetNode.cloneNode({bool})。
</span>        -<span class="ruby"> 深复制：会复制该节点以及它的子节点树，注意父节点并不会复制进去
</span>        -<span class="ruby"> 浅复制：只复制该节点本身
</span>        -<span class="ruby"> 注意：cloneNode()方法不会复制添加到<span class="constant">DOM</span>节点中的<span class="constant">JavaScript</span>属性，例如事件处理程序，这个方法只会复制特性、子节点，其他一切都不会复制（经测试，样式会复制）**<span class="constant">IE</span>在这里存在一个bug，会复制事件处理程序，所以最佳的做法是在复制前移除事件处理程序**
</span>    -<span class="ruby"> **normalize()** 用于处理文档树中的文本节点。 当在某个节点上调用这个方法时，就会在该节点的后代节点中查找是否存在<span class="number">1</span>.文本节点不包含文本<span class="number">2</span> .接连出现两个文本节点 的情况。如果存在<span class="number">1</span>，那么就找到空文本节点然后删除它；如果存在<span class="number">2</span>，就找到相邻的文本节点，然后合并为一个文本节点。</span>
</code></pre><h5 id="Document类型">Document类型</h5><p>在浏览器中，document对象是HTMLDocument(继承自 Document 类型) 的一个实例，表示整个HTML页面，其子节点可能是一个DocumentType(最多一个）、Element（最多一个）、Comment</p>
<blockquote>
<p>document.parentNode == Null //true </p>
<p>document.childNodes == [&lt;!DOCTYPE html&gt;，\<html>\</html>]</p>
</blockquote>
<ul>
<li><p>属性</p>
<ul>
<li>子节点<ul>
<li>documentElement 指向<html></html></li>
<li>body 指向\<body>    </body></li>
</ul>
</li>
<li><p>文档信息</p>
<ul>
<li>title \<title>中的内容</title></li>
<li>url 取得完整的URL</li>
<li>domain 页面的域名</li>
<li>referrer 连接到当前页面的那个页面的URL</li>
<li><p><strong>这些信息都存在于HTTP请求的头部</strong>，这三个属性只有<strong>domain</strong>是可以设置的额，但是出于安全方面的限制，设置的值也是有限制的。</p>
<blockquote>
<p>eg. domain: p2p.wrox.com<br>document.domain = “wrox.com” √<br> document.domain = “abc.com” X<br><strong>不能将这个属性设置为URL中不包含的域</strong></p>
</blockquote>
</li>
<li><p>另外浏览器对domain属性还有一个限制，即如果域名一开始是松散的，就不能再设置为紧绷的了。</p>
<blockquote>
<p>eg. doman: p2p.wrox.com<br>document.domain = “wrox.com”  //松散的<br>document.domain = “p2p.wrox.com”  //紧绷的 （出错）</p>
</blockquote>
</li>
<li><strong>用途★</strong>：当页面中包含来自其他子域的框架或内嵌框架时，通过设置document.domain可以方便的解决跨域问题。由于跨域安全限制，来自不同子域的页面无法通过JS通信。假设有一个页面加载自：www.wrox.com,其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com,现在他们是无法相互访问的，但是通过document.domain都设置为wrox.com之后，它们之间就可以通信了。</li>
</ul>
</li>
<li>查找元素<ul>
<li>getElementById()<ul>
<li>不让表单字段的name特性与其它元素的ID相同，IE7中会有bug</li>
</ul>
</li>
<li>getElementsByTagName(),这个方法会返回包含一个或多个元素的Nodelists，在HTML文档中会返回一个HTMLCollection对象，与Nodelists对象相似也是一个动态的对象<ul>
<li>HTMLCollection对象访问其中的项的方法有三个：方括号、item()、namedItem()这个方法是通过元素的name属性中的值来取得集合中的项，所以方括号中既可以是数字也可以是元素的name属性值</li>
</ul>
</li>
<li>getElementsByName()</li>
</ul>
</li>
<li>特殊集合,这些集合都是HTMLCollection对象<ul>
<li>document.anchors 取得文档中所有包含name特性的\<a>元素</a></li>
<li>document.images</li>
<li>document.links 取得文档中所有带href特性的\<a></a></li>
</ul>
</li>
<li>DOM 一致性检测，由于DOM氛围多个级别，也包含多个部分，所以检测浏览器实现了DOM的哪些部分就十分必要了<ul>
<li>document.implementation.hasFeature()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Element类型">Element类型</h5><p>HTML元素都由HTMLElement类型表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。</p>
<ul>
<li>id</li>
<li>tilte</li>
<li><p>className        </p>
<p>…….略</p>
<p><strong>DocumentFragment</strong>，不能把文档片段直接添加到文档中，但可以将它作为一个仓库来用，比如说要像文档中添加多个节点时，如果逐个添加会导致浏览器反复渲染，为了避免这个问题可以先将这些节点保存在文档片段中，之后再一次性添加到文档中。</p>
</li>
</ul>
<p><strong>Nodelist  HTMLCollection  NamedNodeMap</strong><br>这三个集合都是动态的，也就是说每当文档结构发生变化时，它们都会得到更新。从本质上说，所有Nodelist对象都是在访问DOM文档时实时运行的查询。<strong>应尽量避免访问Nodelist的次数，因为每次访问Nodelist都会运行一次基于文档的查询</strong></p>
<h3 id="DOM扩展">DOM扩展</h3><h4 id="1-选择符API">1.选择符API</h4><p>querySelectorAll() 返回的是一个NodeList实例，但实际上返回的值是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜多的动态查询。这样实现可以避免使用Nodelist对象通常回引起的大多数性能问题。</p>
<h4 id="2-元素遍历">2.元素遍历</h4><h4 id="3-HTML5">3.HTML5</h4><h5 id="与类相关的扩充">与类相关的扩充</h5><ul>
<li>getElementsByClassName(),返回的也是Nodelist对象，因此同样存在性能问题</li>
<li>classList属性<ul>
<li>add()</li>
<li>contains()</li>
<li>remove()</li>
<li>toggle()</li>
<li><strong>IE10+才支持…. 😒</strong><h5 id="焦点管理">焦点管理</h5></li>
<li>document.activeElement,这个属性会引用DOM中当前获得焦点的元素</li>
<li>document.hasFocus() 用于确定文档是否获得了焦点</li>
<li>这两个功能的用途是提高web应用的无障碍性</li>
</ul>
</li>
</ul>
<h5 id="HTMLDocument的变化">HTMLDocument的变化</h5><ul>
<li>readyState属性<ul>
<li>loading,正在加载文档</li>
<li>complete 已经加载完文档</li>
<li><strong>这个指示器可以取代onload事件处理程序</strong></li>
</ul>
</li>
<li>兼容模式<ul>
<li>document.compatMode<br>从IE6开始区分渲染页面的模式是标准还是混杂</li>
</ul>
</li>
<li>head属性<br>用于引用文档的head元素</li>
<li>字符集属性<ul>
<li>charset</li>
<li>defaultCharset</li>
</ul>
</li>
<li>自定义数据属性<ul>
<li>dataset属性，可以通过这个属性获得元素自定义属性值，eg. ele.dataset.folderId<br><strong>注意属性名不包含data-前缀，另外如果剩余属性名中包含’-‘，改成驼峰式写法</strong></li>
</ul>
</li>
</ul>
<h5 id="插入标记">插入标记</h5><ul>
<li>innerHTML <ul>
<li>一些限制：通过innerHTML插入\<script>元素并不会执行其中脚本</li>
<li>并不是所有元素都支持innerHTML属性</li>
</ul>
</li>
<li>outerHTML     <pre><code><span class="bullet">- </span>在读模式下返回调用它的元素及其所有子节点的HTML标签
</code></pre><ul>
<li>在写模式下替换调用它的节点</li>
</ul>
</li>
<li>insertAdjacentHTML(),接受两个参数：插入位置和药插入的HTML文本，第一个蚕食必须是下列值之一<ul>
<li>“beforebegin”</li>
<li>“afterbegin”</li>
<li>“beforeend”</li>
<li>“afterend” 具体意思见P297</li>
</ul>
</li>
<li>内存与性能问题<ul>
<li>使用innerHTML来替换子元素会导致浏览器的内存占用问题，因为元素与事件处理程序或JS对象之间的绑定关系在内存中并没有一并删除，如果这种情况频繁出现页面占用的内存数量就会明显增加，<strong>因此在使用上述的三个方法时，最好先手工删除被替换元素的所有事件处理程序和JS对象属性</strong></li>
<li>使用innerHTML与通过多次DOM操作先创建节点再指定他们之间的关系相比，效率要高得多。这是因为在设置innerHTML或outerHTML时，会创建一个HTML 解析器。这个解析器是在浏览器级别的代码基础上运行的，因此比执行JS快得多。不可避免的，创建和销毁HTML解析器也会带来性能损失。所以要将innerHTML的使用次数控制在合理范围内。</li>
</ul>
</li>
</ul>
<h5 id="scrollIntoView()方法">scrollIntoView()方法</h5><p>该方法可以在所有HTML元素上调用 ,调用元素会出现在视口当中</p>
<h4 id="4-专有扩展">4.专有扩展</h4><h5 id="文档模式">文档模式</h5><h5 id="children属性">children属性</h5><h5 id="contains()方法">contains()方法</h5><h5 id="插入文本">插入文本</h5><h5 id="滚动">滚动</h5><h3 id="DOM2和DOM3">DOM2和DOM3</h3><h4 id="DOM变化_略">DOM变化 略</h4><h5 id="样式">样式</h5><h5 id="元素大小">元素大小</h5><ul>
<li>偏移量<ul>
<li>offsetHeight: 元素在垂直方向上占用的空间大小，以像素为单位i。 包括元素的高度、水平规定条的高度、上下边框的高度。</li>
<li>offsetWidth</li>
<li>offsetLeft: 元素的左外边框至包含元素的左内边框之间的像素距离</li>
<li>offsetHeight: 元素的上外边框至包含元素的上内边框之间的像素距离</li>
<li><strong>注意： offsetParent与parentNode不一定相等</strong></li>
</ul>
</li>
<li>客户区大小<br>指元素内容及其内编剧所占据的空间大小<ul>
<li>clientWidth: 指元素内容区宽度 + 左右内边距宽度</li>
<li>clientHeight: 指元素内容区高度 + 左右内边距高度</li>
</ul>
</li>
<li>滚动大小<ul>
<li>scrollHeight: 在没有滚动条的情况下，元素内容的总高度</li>
<li>scrollWidth: 在没有滚动条的情况下，元素内容的总宽度</li>
<li>scrollTop: 被隐藏在可见内容区上方的像素数，通过改变这个属性可以改变元素的滚动位置</li>
<li>scrollLeft: 被隐藏在可见内容区左方的像素数</li>
</ul>
</li>
<li>确定元素大小 getBoundingClientRect()<br>每个元素都有这个方法，返回一个矩形对象，包含4个属性：left,top,right,bottom。这些属性给出了元素在页面中相对于视口的位置。<strong>IE8前认为文档左上角的坐标是（2，2）</strong></li>
</ul>
</script></li></ul></li></ul>
    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-prototype" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/08/13/prototype/" class="article-date">
  <time datetime="2015-08-13T03:58:57.000Z" itemprop="datePublished">2015-08-13</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/08/13/prototype/">__proto__（隐式原型）与prototype（显式原型）</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h3 id="1-_是什么"><strong>1. 是什么</strong></h3><ul>
<li><p>显式原型 explicit prototype property：每一个<strong>函数</strong>在创建之后都会拥有一个名为<strong>prototype</strong>的属性，这个属性指向函数的原型对象。<br>Note：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。</p>
<blockquote>
<p>NOTE Function objects created using Function.prototype.bind do not have a prototype property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties. ”—– <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5" target="_blank" rel="external">ECMA262 15.3.4.5</a></p>
</blockquote>
</li>
<li><p>隐式原型 implicit prototype link：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<strong>proto</strong>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().Note: Object.prototype 这个对象是个例外，它的<strong>proto</strong>值为null</p>
</li>
<li>二者的关系：隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</li>
</ul>
<h3 id="2-_作用是什么"><strong>2. 作用是什么</strong></h3><ul>
<li><p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p>
<blockquote>
<p>Each constructor is a function that has <strong>a property named “prototype” that is used to implement prototype-based inheritance and shared properties.</strong> —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="external">ECMA262 4.2.1</a></p>
</blockquote>
</li>
<li><p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<strong>proto</strong>依次查找。</p>
<blockquote>
<p>”Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” —-<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.2.1" target="_blank" rel="external">ECMA262 4.2.1</a></p>
</blockquote>
</li>
</ul>
<h3 id="3-_proto的指向"><strong>3. <strong>proto</strong>的指向</strong></h3><p><strong>proto</strong>的指向到底如何判断呢？根据ECMA定义 ‘to the value of its constructor’s “prototype” ’ —-指向创建这个对象的函数（这里且称为构造函数吧，虽然《You Don’t Know JS》的作者一直反复强调JS中没有构造函数，只有构造函数调用）的显式原型。所以关键的点在于找到创建这个对象的构造函数，接下来就来看一下JS中对象被创建的方式，一眼看过去似乎有三种方式：</p>
<p>（1）对象字面量的方式</p>
<p>（2）new 的方式</p>
<p>（3）ES5中的Object.create()</p>
<p>但是我认为本质上只有一种方式，也就是通过new来创建。为什么这么说呢，首先字面量的方式是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy; 再来看看Object.create(),这是ES5中新增的方法，在这之前这被称为原型式继承，</p>
<p>“ 道格拉斯在2006年写了一篇文章，题为 Prototypal Inheritance In JavaScript。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不比因此创建自定义类型，为了达到这个目的，他给出了如下函数: “</p>
<p><pre class="lang:js decode:true ">function object(o){ </pre></p>
<p>function F(){} </p>
<p>F.prototype = o; </p>
<p>return new F();</p>
<p>}<br>– 《JavaScript高级程序设计》P169</p>
<p>所以从实现代码 return new F() 中我们可以看到，这依然是通过new来创建的。不同之处在于由Object.create()创建出来的对象没有构造函数，看到这里你是不是要问，没有构造函数我怎么知道它的<strong>proto</strong>指向哪里呢，其实这里说它没有构造函数是指在Object.create()函数外部我们不能访问到它的构造函数，然而在函数内部实现中是有的，它短暂地存在了那么一会儿。假设我们现在就在函数内部，可以看到对象的构造函数是F, 现在 var f = new F(); f.<strong>proto</strong> === F.prototype === o,因此由Object.create(o)创建出来的对象它的隐式原型指向o.好了，对象的创建方式分析完了，现在你应该能够判断一个对象的<strong>proto</strong>指向谁了。</p>
<p>好吧，还是举一些一眼看过去比较疑惑的例子来巩固一下。</p>
<ul>
<li><p>构造函数的显示原型的隐式原型：</p>
<ul>
<li>内建对象(built-in object)：比如Array（），Array.prototype.<strong>proto</strong>指向什么？Array.prototype也是一个对象，对象就是由 Object（）这个构造函数创建的，因此Array.prototype.<strong>proto</strong> === Object.prototype //true，或者也可以这么理解，所有的内建对象都是由Object()创建而来。</li>
<li><p>自定义对象：</p>
<pre><code>*   默认情况下：<span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>{}; <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); 这时，Foo.prototype.__proto__ === <span class="built_in">Object</span>.prototype,理由同上
</code></pre><ul>
<li><p>其他情况：</p>
<pre><code>*   <span class="function"><span class="keyword">function</span> <span class="title">Bar</span><span class="params">()</span></span>{}; 这时我们想让Foo继承Bar，于是 Foo.prototype = <span class="keyword">new</span> Bar();这个时候 Foo.prototype.__proto__ === Bar.prototype
</code></pre><ul>
<li>我们不想让Foo继承谁，但是我们要自己重新定义Foo.prototype;比如：Foo.prototype = {a:10,b:-10},这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 Foo.prototype.<strong>proto</strong> === Object.prototype</li>
<li>注： 以上两种情况都等于完全重写了Foo.prototype，所以Foo.prototype.constructor也跟着改变了，于是乎constructor这个属性和原来的构造函数Foo（）也就切断了联系。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数的隐式原型</p>
<ul>
<li>既然是构造函数那么它就是Function（）的实例，因此也就指向Function.prototyp<br>比如 Object.<strong>proto</strong> === Function.prototype</li>
</ul>
</li>
</ul>
<h3 id="4-_instanceof"><strong>4. instanceof</strong></h3><p>instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的： 设 L instanceof R , 通过判断 L.<strong>proto</strong>.<strong>proto</strong> ….. === R.prototype,最终返回true or false，也就是沿着L的<strong>proto</strong>一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了</p>
<pre><code><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true </span>
 <span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true </span>
 <span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">//true</span>
 <span class="built_in">Object</span>  <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span>
 <span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">//false</span>
</code></pre><p>文章参考： <a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/" target="_blank" rel="external">JavaScript instanceof 运算符深入剖析</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-css-best-practice" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/04/05/css-best-practice/" class="article-date">
  <time datetime="2015-04-05T07:15:11.000Z" itemprop="datePublished">2015-04-05</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/04/05/css-best-practice/">【译】CSS 最佳实践</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p><div class="layout-wrapper-l2"></div></p>
<p><div class="layout-wrapper-l3"></div></p>
<p><div class="preview-panel"></div></p>
<p><div class="preview-container"></div></p>
<p><div id="preview-contents"></div></p>
<p><div id="wmd-preview-section-216" class="wmd-preview-section preview-content"><a href="https://docs.google.com/presentation/d/1yo83Ifyh6QKF5GonrvLy6QZeWPUn8--EmAKly7ejcb4/edit#slide=id.gbb601923_010" target="_blank" rel="external">原文链接</a></div></p>
<h3 id="目标：">目标：</h3><ol>
<li>语义化（具有可读性）<br>一个CSS选择器的含义和目的应该是易于理解的</li>
<li>模块化（可重用的，灵活的）<br>CSS的规则之间不应该有过于紧密的连接，并且在任何时候都尽可能可以重用</li>
<li>高效（表现）<br>CSS选择器应该是高效的。这一点很重要，由于这有利于提升模块化，并且还可以有效降低文件的大小、减少HTTP请求次数。<br><div id="wmd-preview-section-255" class="wmd-preview-section preview-content">

</div></li>
</ol>
<h3 id="一个典型的例子：’div_*_‘">一个典型的例子：’div * ‘</h3><ul>
<li>过于地宽泛，不具有可读性和可搜索性</li>
<li>不是模块化、可维护的，因为你不得不在其他地方多次重写样式来覆盖它</li>
<li>低性能的，浏览器要为这条规则应用到的每一个元素都检查一遍<br>解决方案：使用一个类名！<br><div id="wmd-preview-section-461" class="wmd-preview-section preview-content">

</div></li>
</ul>
<h3 id="可读性：">可读性：</h3><ul>
<li>尤其注意类名的命名。 使用 ‘.error-content’ 代替’.content’,后者显得含糊不清，前者具有更好的可读性并且便于搜索。</li>
<li>坚持注释。例如当你添加了一组类的时候，写下注释声明他们的用途，他们被用于做什么等等。</li>
<li>你应该让别人像读懂编程语言那样读懂你的CSS，明白你的意图。<br><div id="wmd-preview-section-1027" class="wmd-preview-section preview-content">

</div></li>
</ul>
<h3 id="模块化：">模块化：</h3><ul>
<li><p>避免使用 ‘! important’</p>
<ul>
<li>人们用它来覆盖那些优先级/权重较高的样式。正确地解决方式是在一开始就避免使用过高的权重，这样你就没有用’!important’的必要了。</li>
<li><p>如果你万不得已需要用’!important’,那么就写一个这样的用例</p>
<pre class="lang:default decode:true">.equal-height-column {
margin-bottom:-99999px !important;
margin-bottom:-99999px !important;
}</pre>

<ul>
<li>将容器与内容分离：<br>（1）子元素不应该依赖于父元素的样式<br>（2）如果子元素需要覆盖祖先元素样式，加一个类名，<br>例如 ：用’.alert-error’来代替’.followers .alert’<br>相应的HTML结构如下：<br><pre class="lang:default decode:true">&lt;div class = follwers”&gt;<br>&lt;div class = ‘alert alert error’&gt;<br>&lt;p class = ‘msg’&gt;….&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;div&gt;</pre><br><div id="wmd-preview-section-1328" class="wmd-preview-section preview-content">

</div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="高效：">高效：</h3><ul>
<li><p>CSS 的规则是由右至左地依次应用于元素</p>
<ul>
<li>对于页面上渲染的每一个元素，浏览器都会检查是否有相应的CSS规则应 用于它。</li>
<li><p>例如：”div ul li {color:#fff;}”<br>对于页面上渲染的每一个 li 元素，都会检查一下它是否在一个 ul 中，然 后检查这个 ul 是否在一个 div 中。</p>
<pre><code><span class="number">1.</span>  尽力尝试着最多使用两个选择器来定位你的元素。
</code></pre><p>例如：’.user-list .list-item’<br>不要过于地修饰选择器</p>
<ol>
<li>你只需要直接使用”.user-list”而不是”ul.user-list”</li>
<li>“.user-container .user-list user-link”<br>只需要”.user-container . user-link” 就可以了。<br><div id="wmd-preview-section-1399" class="wmd-preview-section preview-content">

</div></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="不要害怕重构">不要害怕重构</h3><ul>
<li>确认一下是否某个样式来源于不同的文件 （注：不太明白这一条想表达的意思）</li>
<li>检查一下是否有重复或者多余的CSS</li>
<li>如果你看见了一些糟糕的地方，不要害怕去修缮它。这就是那些并不完美的样式如何坚挺地度过了这么多年的原因。<br><br><div id="wmd-preview-section-footnotes" class="preview-content"></div><br><br><br><br><br><div class="extension-preview-buttons closed animate"></div><br><br>&nbsp;</li>
</ul>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTML-CSS/">HTML/CSS</a>
  </div>

			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-javascript-the-core-ec-ecs-ao-vo" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/03/19/javascript-the-core-ec-ecs-ao-vo/" class="article-date">
  <time datetime="2015-03-18T23:39:25.000Z" itemprop="datePublished">2015-03-19</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/03/19/javascript-the-core-ec-ecs-ao-vo/">Javascript核心原理（一）执行环境、执行环境栈、变量对象、活动对象</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h2 id="前言"><strong>前言</strong></h2><p><span class="s1">之前在阅读《Javascript高级程序设计》「4.2执行环境及作用域的」时候，对相关的概念理解得并不是非常的透彻，只是懂了大概的意思。后来在看到「闭包」这一节时书中再一次提到了相关的概念，并且这些是充分理解闭包的必要背景知识，于是这一次我不能再略读了，必须彻彻底底地弄明白。啃了两天的相关文章、资料后，算是有一个比较清晰的认识了，现在记录下来，希望可以帮到同样对相关概念不熟悉的同学，也可以用作自己日后的回顾和修正。</span></p>
<p><span class="s1">注：Execution Context 可以被翻译为「执行上下文」或者「 执行环境」，文中可能都会用到，大家记住是一个东西就可以了。</span></p>
<h2 id="什么是执行环境（Execution_Context）？"><strong>什么是执行环境（Execution Context）？</strong></h2><p><em>“每当程序的执行流进入到一个可执行的代码时，就进入到了一个<strong>执行环境</strong>中。”</em></p>
<p>执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念<br>可执行代码的类型可以为分为：</p>
<ul>
<li>全局代码：程序载入后的默认环境，是运行在程序级别的代码。</li>
<li>函数代码：当执行流进入一个函数后。</li>
<li>Eval代码：Eval 内部的代码。</li>
</ul>
<h2 id="执行环境栈（Execution_Stack）"><strong>执行环境栈（Execution Stack）</strong></h2><p><span class="s1">执行流依次进入的执行环境在逻辑上形成了一个栈，栈的底部永远是全局环境，栈的顶部则是处于活动状态当前的执行环境(浏览器总是执行处于栈顶的上下文)。当执行流进入一个函数时，函数的环境就会被推入这个环境栈中，当函数执行完毕之后，栈将这个执行环境弹出，然后把控制权返回给之前的执行环境。这样实现的原因是由于 Javascript 解释器是单线程的，也就是同一时刻只能发生一件事情，其他等待执行的上下文或事件就会在这个环境栈中排队等待。值得注意的一点是：每次函数的调用都会创建一个执行环境压入栈中，无论是函数内部的函数、还是递归调用等。 </span></p>
<p>我们用数组来表示执行环境栈：</p>
<pre class="lang:default decode:true ">ECStack = [];</pre>
来看下面这个例子：
<pre class="lang:js decode:true">(function foo(i){
  if(i === 3){
    return console.log("Well,the current FunctionContext is finished.");
  }
  else{
    foo(++i);
  }
})(1);</pre>
这个函数会被调用3次，分别是 i = 1,i = 2,i = 3 的时候，每次被调用的时候都会创建一个执行上下文然后压入栈中，执行完毕之后再被弹出，最后将控制权交给栈底的全局环境。当第三次调用 foo 函数也就是 i = 3 时，ECStack 状态如下：
<pre class="lang:js decode:true ">ECStack = 
[
   //栈顶
   FunctionContext - foo(3);
   FunctionContext - foo(2);
   FunctionContext - foo(1);
   GlobalContext
   //栈底
]</pre>
&nbsp;

## **变量对象 （Variable Object）**

_每一个执行环境都有一个与之相关的__变量对象__，其中存储着上下文中声明的：_

*   <span class="s1">变量 VariableDeclaration VD</span>
*   <span class="s1">函数 FunctionDeclaration FD</span>
*   <span class="s1">形式参数 formal parameters</span>

<span class="s1">我们可以用一个对象来表示变量对象：</span>

<pre class="lang:js decode:true ">VO = {

  // 执行上下文中声明的变量、函数、形式参数

}
</pre>

<h2 id="不同执行环境下的变量对象"><strong>不同执行环境下的变量对象</strong></h2><p><span class="s1">变量对象是一个抽象的概念，在进入具体的执行上下文时，变量对象在具体实现上也会有相应地差别。</span></p>
<pre class="lang:default decode:true">AbstractVO (generic behavior of the variable instantiation process)

║
╠══&gt; GlobalContextVO
║      
       (VO === this === global)
║
╚══&gt; FunctionContextVO

       (VO === AO, &lt;arguments&gt; object and &lt;formal parameters&gt; are added)</pre>

<h4 id="全局上下文中的变量对象"><strong>全局上下文中的变量对象</strong></h4><p><span class="s1"><em>全局对象是一个在进入任何执行上下文前就创建出来的对象；此对象以单例形式存在；它的属性在程序任何地方都可以直接访问，其生命周期随着程序的结束而终止。</em></span></p>
<p><span class="s1">全局对象的属性在任何地方都可以被访问到，可以通过 this 或者 DOM 中的 Window 对象来访问。<strong>全局对象中的变量对象就是全局对象本身</strong>，理解这一点很重要，正是因为这个原因才使得可以通过全局对象的属性来访问在全局上下文中声明的变量。</span></p>
<h4 id="函数上下文中的变量对象"><strong>函数上下文中的变量对象</strong></h4><p><span class="s1">当函数被调用时，一个特殊的对象——<strong>活动对象</strong>就随之创建了。变量对象通过函数的 arguments 对象来初始化，arguments 对象是活动对象上的属性，包含了以下属性：</span></p>
<ul>
<li><span class="s1">callee 对当前函数的引用</span></li>
<li><span class="s1">length 传入的实参个数</span></li>
<li><span class="s1">properties-indexes 参数对应的索引值，相应的值和实际传入的参数值是共享的，但不并是存储在同一个地方的</span></li>
</ul>
<h2 id="执行环境的具体细节"><strong>执行环境的具体细节</strong></h2><p>我们同样也可以用一个对象来表示执行上下文：</p>
<p><pre class="lang:default decode:true">ExecutionContextObj = {<br>    scopeChain: { /<em> 变量对象（variableObject）+ 所有父执行上下文的变量对象</em>/ },<br>    variableObject: { /<em>arguments对象，内部变量声明和函数声明 </em>/ },<br>    this:{}<br>}</pre><br>每当一个函数被调用的时候，就会随之创建一个执行上下文，在 Javascript 解释器内部处理执行上下文有两个步骤：</p>
<ul>
<li><p><span class="s1">第一步：创建阶段 （在函数调用之后，函数体执行之前），解释器扫描传递给函数的参数或arguments，本地函数声明和本地变量声明，并创建executionContextObj对象。扫描的结果将完成变量对象的创建</span></p>
<ul>
<li><span class="s1">创建作用域链 （Scope Chain）</span></li>
<li><p><span class="s1">扫描上下文中声明的形式参数、函数以及变量，并依次填充变量对象的属性</span></p>
<pre><code>*   <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"s1"</span>&gt;</span>函数的形参：形参作为属性，对应的实参作为值。对于没有实参的形参，值为undefined。<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><ul>
<li><span class="s1">函数声明（FunctionDeclaration FD）:由函数对象创建出相应的名、值，名就是函数名、值就是函数体。如果变量对象已经包含了同名的属性，就会替换掉它的值。</span></li>
<li><span class="s1">变量声明（VariableDeclaration）:属性名是变量名，值初始化为 undefined。如果变量名和已经存在的属性同名，不会影响到同名的属性。</span></li>
<li><p><span class="s1">注意：函数表达式（FunctionExpression FE）不会成为变量对象的属性，也就是说函数表达式不会影响到变量对象。</span></p>
</li>
<li><p>求出上下文“this”的值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><span class="s1">第二步：代码执行阶段</span></p>
<ul>
<li><span class="s1">这一阶段就会给第一步中初始值为 undefined 的变量赋上相应的值</span><br>我们来看下面这个例子：<br><pre class="lang:js decode:true">(function foo(x,y,z){</pre></li>
</ul>
<p>var a = 1;<br>var b = function(){};<br>function c(){}<br>(function d(){})();</p>
</li>
</ul>
<p>})(10，20);<br>函数调用后，相应的executionContextObj如下：</p>
<p>第一阶段</p>
<p><pre class="lang:default decode:true">  scopeChain:{…},<br>  VO: {<br>    arguments:{<br>      x:10,<br>      y:20,<br>      Z:undefined,<br>      length:2,//这里是实际传入参数的个数<br>      callee:pointer to function foo()<br>    }<br>    a:undefined,<br>    b:undefined,<br>    c:pointer to function c()<br>  },<br>  this:{…}<br>}</pre><br>第二阶段：</p>
<p><pre class="lang:js decode:true">executionContextObj = {<br>  scopeChain:{…},<br>  VO: {<br>    arguments:{<br>      x:10,<br>      y:20,<br>      Z:undefined,<br>      length:2,//这里是实际传入参数的个数<br>      callee:pointer to function foo()<br>    }<br>    a:1,<br>    b:pointer to function b(),<br>    c:pointer to function c()<br>  },<br>  this:{…}<br>}</pre><br>在第二阶段，就会为局部变量 a 、b 赋值，注意到 d 并没有在变量对象中，正如上文中提到的那样，函数表达式是不会影响变量对象的，所以在作用域中任何一个位置引用d都会出现“d is not defined”的错误。</p>
<p>现在你应该非常清楚JS中的变量、函数声明提升是怎么回事了吧。</p>
<p>举个例子吧：</p>
<p><pre class="lang:js decode:true">(function foo(){</pre></p>
<p>  console.log(typeof x);//“function”<br>  var x = 10;<br>  console.log(y);//undefined 而不是 “y is not defined” ,这就是变量声明提升！<br>  var y = 20;<br>  console.log(typeof x);//“number”<br>  function x(){} </p>
<p>})();<br>为什么第一次打印x的类型是函数，第二次打印x的类型又是数字呢。这是因为，根据创建上下文时的规则，函数调用之后会按照顺序依次把函数参数、函数声明、变量声明填充为VO的属性，并且填充变量声明的时候如果同名是不会造成任何影响的，x的值还是函数。</p>
<p>在进入上下文阶段，VO的状态：</p>
<p><pre class="lang:default decode:true ">VO = {<br>  x:pointer to function x()<br>}</pre></p>
<p>// 发现var x = 10;<br>// 如果函数“x”还未定义,则 “x” 的值为undefined,<br>// 但是，在这个例子中<br>// 变量声明并不会影响同名的值为函数的x</p>
<p>VO[‘x’] 的值仍未改变<br>在代码执行阶段，VO的状态：</p>
<p><pre class="lang:default decode:true ">VO[‘x’] = 10;</pre><br>这一阶段，局部变量 x 被赋值，此时之前同名的值为函数的 x 就会被覆盖，大家注意声明和赋值！！第一阶段，局部变量声明同名不会影响；第二阶段局部变量赋值就会产生影响了，毕竟人家是最后赋值的嘛。</p>
<p>最后，再来说说关于变量声明的问题：</p>
<p>在《Javascript高级程序设计》4.2.2一节当中有这么一句话：“如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。” 首先，我们应该先明确一点，<em>使用var关键字是声明变量的唯一方式。如果没有var 的话，例如 a = 5 ，a 就将作为全局对象的一个属性，而不是一个变量。</em></p>
<p>区别如下：</p>
<p><pre class="lang:js decode:true ">alert(x); // “x” is not defined<br>alert(b); // “undefined</pre></p>
<p>x = 10;<br>var y = 20;<br>进入上下文后第一阶段：</p>
<p><pre class="lang:default decode:true ">VO = {<br>  x:10;<br>}</pre><br>VO 中并没有y的原因是，y 并不是变量。另外还要注意的一点就是，没有通过 var 声明的属性可以通过delete操作符删除，而通过var声明的变量就不可以。</p>
<p>啊，差不多把要说的点都说了，如果大家觉得我总结得不好，可以看看以下几篇原文，然后欢迎讨论指出问题哈。</p>
<p>文章参考：</p>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 1. Execution Contexts.</a> |<a href="http://goddyzhao.tumblr.com/post/10020230352/execution-context" target="_blank" rel="external">中文版</a></li>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object.</a> |<a href="http://goddyzhao.tumblr.com/post/11141710441/variable-object" target="_blank" rel="external">中文版</a></li>
<li><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="external">What is the Execution Context &amp; Stack in JavaScript?</a> | <a href="http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="external">中文版</a><br>&nbsp;</li>
</ul>
<p>&nbsp;</p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript-The-Core/">Javascript The Core</a>
  </div>

			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-call-by-sharing" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2014/12/19/call-by-sharing/" class="article-date">
  <time datetime="2014-12-19T05:11:50.000Z" itemprop="datePublished">2014-12-19</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2014/12/19/call-by-sharing/">Javascript中值的访问与参数传递问题</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h3 id="数据类型">数据类型</h3><p>在 javascript 中数据类型可以分为两类：</p>
<ul>
<li><strong>原始数据类型值</strong> primitive type，比如Undefined,Null,Boolean,Number,String。</li>
<li><strong>引用类型值</strong>，也就是对象类型 Object type,比如Object,Array,Function,Date等。</li>
</ul>
<h3 id="声明变量时不同的内存分配">声明变量时不同的内存分配</h3><ul>
<li>原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</li>
<li>引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。<br><img src="http://m1.yea.im/43N.jpg" alt="image"></li>
</ul>
<h3 id="不同的内存分配机制也带来了不同的访问机制">不同的内存分配机制也带来了不同的访问机制</h3><p>在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的<strong>按引用访问</strong>。而原始类型的值则是可以直接访问到的。</p>
<h3 id="复制变量时的不同">复制变量时的不同</h3><ul>
<li><p>原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。<br><img src="http://m1.yea.im/43P.jpg" alt="image"></p>
</li>
<li><p>引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）<br>&nbsp;</p>
</li>
</ul>
<p><img src="http://m1.yea.im/43Q.jpg" alt="image"></p>
<h3 id="参数传递的不同">参数传递的不同</h3><p>首先我们应该明确一点：ECMAScript中所有函数的参数都<strong>是按值来传递</strong>的。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。 （我对比了一下，这里和复制变量时遵循的机制完全一样的嘛，你可以简单地理解为传递参数的时候，就是把实参复制给形参的过程）</p>
<ul>
<li>原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</li>
<li>引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧：<br><img src="http://m1.yea.im/43P.jpg" alt="image"><br><span style="line-height: 1.6;">所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！来看下面这个例子吧：（传说中的call by sharing）</span><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	<span class="keyword">value</span>:<span class="string">'111'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  	<span class="keyword">value</span>:<span class="string">'222'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">changeStuff</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  	obj.<span class="keyword">value</span> = <span class="string">'333'</span>;</span><br><span class="line">  	obj = obj2;</span><br><span class="line">  	<span class="keyword">return</span> obj.<span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = changeStuff(obj1);</span><br><span class="line"></span><br><span class="line">console.log(foo);<span class="comment">// '222' 参数obj指向了新的对象obj2</span></span><br><span class="line">console.log(obj1.<span class="keyword">value</span>);</span><br><span class="line"><span class="comment">/* '333' obj1仍然指向原来的对象,之所以value改变了,</span><br><span class="line"> *是因为changeStuff里的第一条语句，这个时候obj是指向obj1的 .</span><br><span class="line"> *再啰嗦一句，如果是按引用传递的话，这个时候obj1.value应该是等于'222'的</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，以上就是关于这个问题的全部解释了。</p>
<p>各位有兴趣的话可以去了解一下call by value ,call by reference call by sharing 等函数传递的机制<a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">call by sharing</a></p>
<p>还有stackoverflow上对于函数传递的这个问题解释得相当精辟，值得一看。（下面有链接）</p>
<p>参考：</p>
<ul>
<li><a href="http://www.w3school.com.cn/js/pro_js_value.asp" target="_blank" rel="external">ECMAScript 原始值和引用值</a></li>
<li><a href="http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1" target="_blank" rel="external">Is JavaScript a pass-by-reference or pass-by-value language?</a></li>
<li>我的红宝书《javascript高级程序设计》P69-P71</li>
</ul>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </div>

			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-pseudo-element" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2014/11/02/pseudo-element/" class="article-date">
  <time datetime="2014-11-02T04:24:23.000Z" itemprop="datePublished">2014-11-02</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2014/11/02/pseudo-element/">什么是伪元素:after和:before</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>或许你在很多网页的源码上已经不止一次的见过:before 和 :after了，或者是别人利用伪元素做出各种酷炫效果..看见它俩陌生的面孔是不是有些害怕但又很想征服它们运用在自己的项目中呢？希望读完本篇文章后你就可以和它俩混熟了~</p>
<p>在学会使用伪元素之前，先来了解一下什么是伪元素以及它们的工作原理。</p>
<p>很多时候我们希望实现某种效果或是完成某些工作，但是又不希望破坏HTML的语义化，增加一个标签仅仅是为了去达成我们的目的却和结构完全没关系，一名优秀的前端工程师是绝对不会这么干的。那么这个时候，伪元素就该闪亮登场了~ </p>
<p>首先还是让我们来看看官方对伪元素的定义吧: <a href="http://www.w3.org/TR/selectors/#pseudo-elements" target="_blank" rel="external"><strong>Pseudo-elements</strong></a> </p>
<p>额，为了照顾看见英文就头疼的同学，我尽力翻译一下吧：</p>
<p>“伪元素在标记语言创建的DOM树之外创造了一种抽象（的对象）。例如：标记语言并不提供可以直接控制元素中第一行内容或第一个字这样的机制，而伪元素就允许开发人员去特指这些无法触及的内容；伪元素也提供了开发人员一种方法，可以特指一些原本在源文档（Dom树）中并不存在的内容（例如：:before 和 :after可以<strong>创建</strong>内容）。”</p>
<p><strong>tip</strong>:关于双冒号还是单冒号的问题，双冒号::是CSS3的新语法，为了区分伪类和伪元素，但是IE8不兼容双冒号语法，所以如果要考虑到兼容IE建议使用单冒号，否则应当遵循最新规范的双冒号语法。</p>
<p>具体用法：</p>
<p>还是举个栗子最直观</p>
<pre class="lang:css decode:true ">&lt;p&gt;Today is a fine day&lt;/p&gt;

&lt;p&gt;
  &lt;before&gt; Yes &lt;/before&gt;
   Today is a fine day
  &lt;after&gt;  No  &lt;/after&gt;
&lt;/p&gt;</pre> 

<p>上面3-7行的代码是以下CSS转换成标记语言的等同效果</p>
<pre class="lang:css decode:true ">p:before{
  content:"Yes";
}

p:after{
  content:"No";
}</pre> 

<p>也就是说，:before是在元素的内容之前插入/创建一个虚拟的元素，:after 是在元素的内容之后插入/创建一个虚拟的元素 （我是这么理解的：相当于插入一个first-child和last-child,如果这么理解不恰当，请指出~）</p>
<p>其中，content属性是必须声明的，它的值可以是：</p>
<p>1.字符串：eg. content:”abcd”;<br>2.图片：eg. content:url(…);<br>  注：图片会按实际尺寸插入并且无法改变其大小。<br>3.空：eg. content:” “;<br>  感觉这个用途是最广泛的，可以发挥你的想象让这个空胜于有。比如可以设为空然后给伪元素设置背景图像，这样就可以修改图片的大小了。<br>4.计数器：eg. content: counter(li); 在列表时计算行数非常方便。</p>
<p><strong>tip:</strong>伪元素默认生成的是一个<strong>内联元素</strong>，可以根据需要设置display:block;</p>
<p>浏览器支持情况：</p>
<p>1.Firefox 3.5- 不支持伪元素的绝对定位。<br>2.Opera 9.2里，伪元素里的空格会显示，如同在pre里一样。<br>3.IE 8 不支持伪元素里的z-index</p>
<p>今天就介绍到这里，在下篇文章中将向大家展示一些伪元素的妙用和那些酷炫效果。</p>
<p>文章参考：</p>
<p><a href="http://www.tinghaige.com/understanding-pseudo-element-before-and-after.html" title="理解伪元素:Before和:After" target="_blank" rel="external">理解伪元素:Before和:After</a><br><a href="http://ithelp.ithome.com.tw/question/10128451" title="CSS沒有極限 - 別忘了偽元素" target="_blank" rel="external">CSS沒有極限 - 別忘了偽元素</a><br><a href="http://www.webhek.com/after-before/" title="伪元素::after和::before" target="_blank" rel="external">伪元素::after和::before</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTML-CSS/">HTML/CSS</a>
  </div>

			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
  

    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.fehacker.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">Okiilemon</a>
	</h1>
	<span class="copyright">
		&copy; 2015 wuxiaohan<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>