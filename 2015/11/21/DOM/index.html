<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Okiilemon</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="DOM深入解析DOM  Document Object Model 是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树。
1998.10 W3C推荐标准 DOM1级规范DOM1. Node类型
每个节点都有一个nodeType属性，element类型对应的数值常量是 1 ，由于IE不支持Node接口，因此最好将nodeType属性与数值比较，来确保浏览器兼容性。
nodeNam">
<meta property="og:type" content="article">
<meta property="og:title" content="Okiilemon">
<meta property="og:url" content="http://www.fehacker.com/2015/11/21/DOM/index.html">
<meta property="og:site_name" content="Okiilemon">
<meta property="og:description" content="DOM深入解析DOM  Document Object Model 是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树。
1998.10 W3C推荐标准 DOM1级规范DOM1. Node类型
每个节点都有一个nodeType属性，element类型对应的数值常量是 1 ，由于IE不支持Node接口，因此最好将nodeType属性与数值比较，来确保浏览器兼容性。
nodeNam">
<meta property="og:updated_time" content="2015-08-05T11:56:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Okiilemon">
<meta name="twitter:description" content="DOM深入解析DOM  Document Object Model 是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树。
1998.10 W3C推荐标准 DOM1级规范DOM1. Node类型
每个节点都有一个nodeType属性，element类型对应的数值常量是 1 ，由于IE不支持Node接口，因此最好将nodeType属性与数值比较，来确保浏览器兼容性。
nodeNam">
  
    <link rel="alternative" href="/atom.xml" title="Okiilemon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">Okiilemon</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.fehacker.com"></form>
	</div>
</header>
    <div id="main">
      <article id="post-DOM" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/11/21/DOM/" class="article-date">
  <time datetime="2015-11-20T16:47:55.000Z" itemprop="datePublished">2015-11-21</time>
</a>
		</span>
		<span class="meta-elements author">wuxiaohan</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
	</header>
	<div class="entry-content">
		
    	<h3 id="DOM深入解析">DOM深入解析</h3><p>DOM  Document Object Model 是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树。</p>
<h4 id="1998-10_W3C推荐标准_DOM1级规范">1998.10 W3C推荐标准 DOM1级规范</h4><h3 id="DOM">DOM</h3><h5 id="1-_Node类型">1. Node类型</h5><ul>
<li>每个节点都有一个<strong>nodeType</strong>属性，element类型对应的数值常量是 1 ，由于IE不支持Node接口，因此最好将nodeType属性与数值比较，来确保浏览器兼容性。</li>
<li><strong>nodeName</strong> 与 <strong>nodeValue</strong>, nodeName中保存着元素的标签名，只有部分node的nodeValue属性有值，其余都是null.</li>
<li>节点关系<ul>
<li>每一个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一个类数组对象，用于保存一组有序的节点，虽然这个对象也有length属性，但它并不是一个Array的实例。<ul>
<li><strong>Nodelist对象是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够实时反应在Nodelist对象中。</strong></li>
<li>可以通过方括号或者item方法来方位保存在NodeList在的节点</li>
<li>将NodeList对象转换为数组的方法：Array.prototype.slice.call( someNode.childNodes, 0 ) , 在IE8以前的版本不支持，需要手动枚举所有成员然后压入数组</li>
<li>每个节点都有如下关系节点属性：<ul>
<li>parentNode 指向父节点</li>
<li>nextSibling() previousSibling() 同胞节点之间</li>
<li>firstChild, lastChild 子节点</li>
</ul>
</li>
<li>节点方法 hasChildNodes(), 该节点如果包含一个以上子节点的情况下返回true,比childNodes.length来判断方便许多</li>
<li><strong>关于childNode.length IE9之前的版本不会为空白符创建节点</strong></li>
</ul>
</li>
</ul>
</li>
<li>操作节点<ul>
<li><strong>appendChild()</strong>接受一个参数，要插入的节点。用法：parent.appendChild(child) 用于向parent 的childNodes列表的末尾添加一个节点，return 新增节点</li>
<li>i<strong>nsertBrfore（）</strong> 接受两个参数，要插入的节点和作为参照的节点。用法：parent.insertBefore(newNode, dependNode), 如果第二个参数也就是参照节点是null，则执行与appendChild相同的操坐，return 新增节点。<ul>
<li>另外说说利用 insertBefore（） 实现 insertAfter() 的方法, 首先判断一下参照节点的下一个同胞节点是否存在，存在说明不是最后一个节点, 不存在就直接append<blockquote>
<p>function insertBefore(newNode, dependNode){<br>var parent = newNode.parentElement;<br>  if( dependNode.nextSibling === null ){       </p>
<pre><code><span class="tag">parent</span><span class="class">.appendChild</span>(<span class="tag">newNode</span>);      
</code></pre><p>  }<br>  else{         </p>
<pre><code>parent.<span class="function"><span class="title">insertBefore</span><span class="params">( newNode, dependNode.nextSibling )</span></span>      
</code></pre><p>  }<br>}</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>replaceChild()</strong> 接受两个参数，要插入的节点和要替换的节点，要替换的节点将由这个方法<strong>返回</strong>并从文档树中移除，同时被要插入的节点替换。被替换的节点仍然还在文档中，只是在文档中已经没有了自己位置。方法：parent.replaceChild(newNode，replacedChild) </li>
<li><strong>removeChild()</strong>，接受一个参数，即要被移除的节点，被移除的节点被返回。被移除的节点仍然在文档中，只是在文档中没有了自己位置。 方法： parent.removeChild(child)</li>
</ul>
</li>
</ul>
<pre><code>-<span class="ruby">--
</span>（以上四个方法都需要先取得父节点，并不是所有类型都有父节点）
-<span class="ruby"> 两个所有类型节点都有的方法
</span>    -<span class="ruby"> **cloneNode()**, 用于创建调用这个方法的节点的一个完全相同的副本, targetNode.cloneNode({bool})。
</span>        -<span class="ruby"> 深复制：会复制该节点以及它的子节点树，注意父节点并不会复制进去
</span>        -<span class="ruby"> 浅复制：只复制该节点本身
</span>        -<span class="ruby"> 注意：cloneNode()方法不会复制添加到<span class="constant">DOM</span>节点中的<span class="constant">JavaScript</span>属性，例如事件处理程序，这个方法只会复制特性、子节点，其他一切都不会复制（经测试，样式会复制）**<span class="constant">IE</span>在这里存在一个bug，会复制事件处理程序，所以最佳的做法是在复制前移除事件处理程序**
</span>    -<span class="ruby"> **normalize()** 用于处理文档树中的文本节点。 当在某个节点上调用这个方法时，就会在该节点的后代节点中查找是否存在<span class="number">1</span>.文本节点不包含文本<span class="number">2</span> .接连出现两个文本节点 的情况。如果存在<span class="number">1</span>，那么就找到空文本节点然后删除它；如果存在<span class="number">2</span>，就找到相邻的文本节点，然后合并为一个文本节点。</span>
</code></pre><h5 id="Document类型">Document类型</h5><p>在浏览器中，document对象是HTMLDocument(继承自 Document 类型) 的一个实例，表示整个HTML页面，其子节点可能是一个DocumentType(最多一个）、Element（最多一个）、Comment</p>
<blockquote>
<p>document.parentNode == Null //true </p>
<p>document.childNodes == [&lt;!DOCTYPE html&gt;，\<html>\</html>]</p>
</blockquote>
<ul>
<li><p>属性</p>
<ul>
<li>子节点<ul>
<li>documentElement 指向<html></html></li>
<li>body 指向\<body>    </body></li>
</ul>
</li>
<li><p>文档信息</p>
<ul>
<li>title \<title>中的内容</title></li>
<li>url 取得完整的URL</li>
<li>domain 页面的域名</li>
<li>referrer 连接到当前页面的那个页面的URL</li>
<li><p><strong>这些信息都存在于HTTP请求的头部</strong>，这三个属性只有<strong>domain</strong>是可以设置的额，但是出于安全方面的限制，设置的值也是有限制的。</p>
<blockquote>
<p>eg. domain: p2p.wrox.com<br>document.domain = “wrox.com” √<br> document.domain = “abc.com” X<br><strong>不能将这个属性设置为URL中不包含的域</strong></p>
</blockquote>
</li>
<li><p>另外浏览器对domain属性还有一个限制，即如果域名一开始是松散的，就不能再设置为紧绷的了。</p>
<blockquote>
<p>eg. doman: p2p.wrox.com<br>document.domain = “wrox.com”  //松散的<br>document.domain = “p2p.wrox.com”  //紧绷的 （出错）</p>
</blockquote>
</li>
<li><strong>用途★</strong>：当页面中包含来自其他子域的框架或内嵌框架时，通过设置document.domain可以方便的解决跨域问题。由于跨域安全限制，来自不同子域的页面无法通过JS通信。假设有一个页面加载自：www.wrox.com,其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com,现在他们是无法相互访问的，但是通过document.domain都设置为wrox.com之后，它们之间就可以通信了。</li>
</ul>
</li>
<li>查找元素<ul>
<li>getElementById()<ul>
<li>不让表单字段的name特性与其它元素的ID相同，IE7中会有bug</li>
</ul>
</li>
<li>getElementsByTagName(),这个方法会返回包含一个或多个元素的Nodelists，在HTML文档中会返回一个HTMLCollection对象，与Nodelists对象相似也是一个动态的对象<ul>
<li>HTMLCollection对象访问其中的项的方法有三个：方括号、item()、namedItem()这个方法是通过元素的name属性中的值来取得集合中的项，所以方括号中既可以是数字也可以是元素的name属性值</li>
</ul>
</li>
<li>getElementsByName()</li>
</ul>
</li>
<li>特殊集合,这些集合都是HTMLCollection对象<ul>
<li>document.anchors 取得文档中所有包含name特性的\<a>元素</a></li>
<li>document.images</li>
<li>document.links 取得文档中所有带href特性的\<a></a></li>
</ul>
</li>
<li>DOM 一致性检测，由于DOM氛围多个级别，也包含多个部分，所以检测浏览器实现了DOM的哪些部分就十分必要了<ul>
<li>document.implementation.hasFeature()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Element类型">Element类型</h5><p>HTML元素都由HTMLElement类型表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。</p>
<ul>
<li>id</li>
<li>tilte</li>
<li><p>className        </p>
<p>…….略</p>
<p><strong>DocumentFragment</strong>，不能把文档片段直接添加到文档中，但可以将它作为一个仓库来用，比如说要像文档中添加多个节点时，如果逐个添加会导致浏览器反复渲染，为了避免这个问题可以先将这些节点保存在文档片段中，之后再一次性添加到文档中。</p>
</li>
</ul>
<p><strong>Nodelist  HTMLCollection  NamedNodeMap</strong><br>这三个集合都是动态的，也就是说每当文档结构发生变化时，它们都会得到更新。从本质上说，所有Nodelist对象都是在访问DOM文档时实时运行的查询。<strong>应尽量避免访问Nodelist的次数，因为每次访问Nodelist都会运行一次基于文档的查询</strong></p>
<h3 id="DOM扩展">DOM扩展</h3><h4 id="1-选择符API">1.选择符API</h4><p>querySelectorAll() 返回的是一个NodeList实例，但实际上返回的值是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜多的动态查询。这样实现可以避免使用Nodelist对象通常回引起的大多数性能问题。</p>
<h4 id="2-元素遍历">2.元素遍历</h4><h4 id="3-HTML5">3.HTML5</h4><h5 id="与类相关的扩充">与类相关的扩充</h5><ul>
<li>getElementsByClassName(),返回的也是Nodelist对象，因此同样存在性能问题</li>
<li>classList属性<ul>
<li>add()</li>
<li>contains()</li>
<li>remove()</li>
<li>toggle()</li>
<li><strong>IE10+才支持…. 😒</strong><h5 id="焦点管理">焦点管理</h5></li>
<li>document.activeElement,这个属性会引用DOM中当前获得焦点的元素</li>
<li>document.hasFocus() 用于确定文档是否获得了焦点</li>
<li>这两个功能的用途是提高web应用的无障碍性</li>
</ul>
</li>
</ul>
<h5 id="HTMLDocument的变化">HTMLDocument的变化</h5><ul>
<li>readyState属性<ul>
<li>loading,正在加载文档</li>
<li>complete 已经加载完文档</li>
<li><strong>这个指示器可以取代onload事件处理程序</strong></li>
</ul>
</li>
<li>兼容模式<ul>
<li>document.compatMode<br>从IE6开始区分渲染页面的模式是标准还是混杂</li>
</ul>
</li>
<li>head属性<br>用于引用文档的head元素</li>
<li>字符集属性<ul>
<li>charset</li>
<li>defaultCharset</li>
</ul>
</li>
<li>自定义数据属性<ul>
<li>dataset属性，可以通过这个属性获得元素自定义属性值，eg. ele.dataset.folderId<br><strong>注意属性名不包含data-前缀，另外如果剩余属性名中包含’-‘，改成驼峰式写法</strong></li>
</ul>
</li>
</ul>
<h5 id="插入标记">插入标记</h5><ul>
<li>innerHTML <ul>
<li>一些限制：通过innerHTML插入\<script>元素并不会执行其中脚本</li>
<li>并不是所有元素都支持innerHTML属性</li>
</ul>
</li>
<li>outerHTML     <pre><code><span class="bullet">- </span>在读模式下返回调用它的元素及其所有子节点的HTML标签
</code></pre><ul>
<li>在写模式下替换调用它的节点</li>
</ul>
</li>
<li>insertAdjacentHTML(),接受两个参数：插入位置和药插入的HTML文本，第一个蚕食必须是下列值之一<ul>
<li>“beforebegin”</li>
<li>“afterbegin”</li>
<li>“beforeend”</li>
<li>“afterend” 具体意思见P297</li>
</ul>
</li>
<li>内存与性能问题<ul>
<li>使用innerHTML来替换子元素会导致浏览器的内存占用问题，因为元素与事件处理程序或JS对象之间的绑定关系在内存中并没有一并删除，如果这种情况频繁出现页面占用的内存数量就会明显增加，<strong>因此在使用上述的三个方法时，最好先手工删除被替换元素的所有事件处理程序和JS对象属性</strong></li>
<li>使用innerHTML与通过多次DOM操作先创建节点再指定他们之间的关系相比，效率要高得多。这是因为在设置innerHTML或outerHTML时，会创建一个HTML 解析器。这个解析器是在浏览器级别的代码基础上运行的，因此比执行JS快得多。不可避免的，创建和销毁HTML解析器也会带来性能损失。所以要将innerHTML的使用次数控制在合理范围内。</li>
</ul>
</li>
</ul>
<h5 id="scrollIntoView()方法">scrollIntoView()方法</h5><p>该方法可以在所有HTML元素上调用 ,调用元素会出现在视口当中</p>
<h4 id="4-专有扩展">4.专有扩展</h4><h5 id="文档模式">文档模式</h5><h5 id="children属性">children属性</h5><h5 id="contains()方法">contains()方法</h5><h5 id="插入文本">插入文本</h5><h5 id="滚动">滚动</h5><h3 id="DOM2和DOM3">DOM2和DOM3</h3><h4 id="DOM变化_略">DOM变化 略</h4><h5 id="样式">样式</h5><h5 id="元素大小">元素大小</h5><ul>
<li>偏移量<ul>
<li>offsetHeight: 元素在垂直方向上占用的空间大小，以像素为单位i。 包括元素的高度、水平规定条的高度、上下边框的高度。</li>
<li>offsetWidth</li>
<li>offsetLeft: 元素的左外边框至包含元素的左内边框之间的像素距离</li>
<li>offsetHeight: 元素的上外边框至包含元素的上内边框之间的像素距离</li>
<li><strong>注意： offsetParent与parentNode不一定相等</strong></li>
</ul>
</li>
<li>客户区大小<br>指元素内容及其内编剧所占据的空间大小<ul>
<li>clientWidth: 指元素内容区宽度 + 左右内边距宽度</li>
<li>clientHeight: 指元素内容区高度 + 左右内边距高度</li>
</ul>
</li>
<li>滚动大小<ul>
<li>scrollHeight: 在没有滚动条的情况下，元素内容的总高度</li>
<li>scrollWidth: 在没有滚动条的情况下，元素内容的总宽度</li>
<li>scrollTop: 被隐藏在可见内容区上方的像素数，通过改变这个属性可以改变元素的滚动位置</li>
<li>scrollLeft: 被隐藏在可见内容区左方的像素数</li>
</ul>
</li>
<li>确定元素大小 getBoundingClientRect()<br>每个元素都有这个方法，返回一个矩形对象，包含4个属性：left,top,right,bottom。这些属性给出了元素在页面中相对于视口的位置。<strong>IE8前认为文档左上角的坐标是（2，2）</strong></li>
</ul>
</script></li></ul></li></ul>
    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
  
    <a href="/2015/08/13/prototype/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          __proto__（隐式原型）与prototype（显式原型）
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.fehacker.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">Okiilemon</a>
	</h1>
	<span class="copyright">
		&copy; 2015 wuxiaohan<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>