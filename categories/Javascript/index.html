<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Okiilemon</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/lemon24.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/lemon50.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/links" target="_self" class="nav-list-link">LINKS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/13/prototype/" class="post-title-link">__proto__（隐式原型）与prototype（显式原型）</a></h2><div class="post-meta"><div class="post-time">Aug 13, 2015</div></div><div class="post-content"><h3 id="1-_是什么"><strong>1. 是什么</strong></h3><ul>
<li><p>显式原型 explicit prototype property：每一个<strong>函数</strong>在创建之后都会拥有一个名为<strong>prototype</strong>的属性，这个属性指向函数的原型对象。<br>Note：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。</p>
<blockquote>
<p>NOTE Function objects created using Function.prototype.bind do not have a prototype property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties. ”—– <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5">ECMA262 15.3.4.5</a></p>
</blockquote>
</li>
<li><p>隐式原型 implicit prototype link：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<strong>proto</strong>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().Note: Object.prototype 这个对象是个例外，它的<strong>proto</strong>值为null</p>
</li>
<li>二者的关系：隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</li>
</ul></div><a href="2015/08/13/prototype/" class="read-more">... more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/19/call-by-sharing/" class="post-title-link">Javascript中值的访问与参数传递问题</a></h2><div class="post-meta"><div class="post-time">Dec 19, 2014</div></div><div class="post-content"><h3 id="数据类型">数据类型</h3><p>在 javascript 中数据类型可以分为两类：</p>
<ul>
<li><strong>原始数据类型值</strong> primitive type，比如Undefined,Null,Boolean,Number,String。</li>
<li><strong>引用类型值</strong>，也就是对象类型 Object type,比如Object,Array,Function,Date等。</li>
</ul>
<h3 id="声明变量时不同的内存分配">声明变量时不同的内存分配</h3><ul>
<li>原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</li>
<li>引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。<br><img src="http://m1.yea.im/43N.jpg" alt="image"></li>
</ul></div><a href="2014/12/19/call-by-sharing/" class="read-more">... more</a></article></li></ul></section><footer><div class="paginator"><a class="prev"> </a><a class="prev"> </a></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-70485577-1",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>